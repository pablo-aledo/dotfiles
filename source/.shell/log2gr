[ -e ~/log2gr ] && LOG2GR_DIR=~/log2gr

ctags_index(){
    ctags -R --fields=+zln
    cat tags | grep -F $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g')
        file=$(echo $line | awk '{print $2}')
        end=$(awk 'NR > first && /^}$/ { print NR; exit }' first=$ini $file)
        # end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
        #                          NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done
}

ctags_extract(){
	cat tags | grep -F $1 | while read line
 	do
		fname="$(echo $line | awk '{print $1}')"
		file="$(echo $line | awk '{print $2}')"
	   	start="$(echo $line | sed 's/.*line:\([0-9]*\).*/\1/g')"
		end="$(echo $line | sed 's/.*end:\([0-9]*\).*/\1/g')"
		echo "cat $file | head -n $end | tail -n $(( $end - $start + 1 )) > functions/$fname"
   	done
}

ctags_info(){
	#grep -Rin 'log\.' G Msg | sed 's/^\([^:]*\):.*.Msg."\([^"]*\)".*/\2 -> \1/g' > /tmp/log2fn

	ls | sort -u > /tmp/list
	ls | while read fname
	do
		comm -12 <(sed 1d $fname | keywords_lowercase=false tokenize | sort -u) <(cat /tmp/list) | while read call
		do
			echo "$fname -> $call"
		done
	done > /tmp/calls

    cat ../tags | grep kind:f | sed -e 's/\t/@/g' -e 's/line://g' -e 's/end://g' | awk 'BEGIN{FS="@"}{print $1" "$2" "$5" "$7}' > /tmp/index
}

call_path(){
	src=$1
	dst=$2
    #echo $src $dst > /tmp/dj.log
	[ "$src" = "$dst" ] && return
	dijkstra -dp $src <(echo 'digraph G {'; cat $LOG2GR_DIR/$project/calls | sed 's/\./DOT/g' ; echo '}') | paste -d' ' -s  | sed 's/;/\n/g' | grep '\[' | grep -v digraph > /tmp/dists
	dist=$( cat /tmp/dists | grep "\<$dst\>" | grep -v "prev=\<$dst\>" | grep dist | sed 's/^[^=]*=\([0-9]*\)\.[0-9]*.*/\1/g' )
	[ "$dist" = "" ] && return

	djpath=$dst; node=$dst
	while true
	do
		prev=$(cat /tmp/dists | grep "\<$node\>" | grep -v "prev=\<$node\>" | cut -d= -f3 | sed 's/.$//g')
		node=$prev
		djpath=$node@$djpath
		[ "$node" = "$src" ] && break
	done
	[ "$dist" -lt 10 ] && echo $djpath | sed 's/@/ -> /g' | sed 's/DOT/./g'
}

log2gr(){
    project=$1; shift
    source $LOG2GR_DIR/$project/log2fn
	cat $1 | log2fn > /tmp/fn_trace; shift

    seeds=()
    if [ $# -gt 0 ]
    then
        for a in $*; do seeds+=$a; done
    else
        comm -12 <(sort -u $LOG2GR_DIR/$project/seeds) <(sort -u /tmp/fn_trace) | while read a; do seeds+=$a; done
    fi

	rm -fr /tmp/lost_context /tmp/ok_context
	for seed in $seeds
	do
		stack="@$seed"
		echo "$seed" >> /tmp/ok_context
		cat /tmp/fn_trace | uniq | while read input
		do
			stack_bak=$stack
			error=false
			while true
			do
				last=$(echo $stack | sed 's/@/\n/g' | tail -n1 )
				stack=$(echo $stack | sed 's/@[^@]*$//g')
				[ "$(call_path $last $input)" != "" ] && { cpath="$(call_path $last $input)" ; break }
				[ "$stack" = "" ] && { stack=$stack_bak; error=true; echo $input >> /tmp/lost_context; break }
			done
			[ $error = true ] && continue
    		echo $input >> /tmp/ok_context
			stack="$stack@$(echo $cpath | sed 's/ -> /@/g')"
			echo $cpath
		done
	done | while read line; do echo $line | sed 's/ -> /\n/g' | awk 'NR>1{print prev " -> " $0}{ prev=$0 }'; done | sort -u > $LOG2GR_DIR/$project/graph

    if [ -e $LOG2GR_DIR/$project/postprocess ]
    then
        ( cd $LOG2GR_DIR/$project; source ./postprocess )
    else
	    cat $LOG2GR_DIR/$project/graph
    fi

}

lgr_postprocess(){
cat << EOF
\cp graph{,.bak}
touch prev_graph

comm -12 <(sort -u graph) <(sort -u prev_graph) > /tmp/graph
comm -23 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: green } }/g' >> /tmp/graph
comm -13 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: red } }/g' >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat tooltips | grep "^\$line:"
done >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat style | grep "^\$line:"
done >> /tmp/graph

\mv /tmp/graph graph
EOF
}
