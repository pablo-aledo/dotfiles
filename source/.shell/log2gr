[ -e ~/log2gr ] && LOG2GR_DIR=~/log2gr

ctags_index(){
    ctags -R --fields=+zln
    cat tags | grep -F $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g')
        file=$(echo $line | awk '{print $2}')
        end=$(awk 'NR > first && /^}$/ { print NR; exit }' first=$ini $file)
        # end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
        #                          NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done > tags2
    \mv tags2 tags
}

ctags_index_groovy(){
        #--regex-groovy='/^[ \t]*[(private|public|protected) ( \t)]*def[ \t]+([A-Za-z0-9_]+)[ \t()=]*\{/\1/f,function,functions/' \*/

        # --langdef=groovy
        # --langmap=groovy:.groovy
        # --regex-groovy=/^[ \t]*package[ \t]+([a-zA-Z0-9.-_]+)/\1/p,package/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*(abstract|final|static)?[ \t]*class[ \t]+([A-Za-z0-9_]+)/\3/c,class/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*trait[ \t]+([A-Za-z0-9_]+)/\2/t,trait/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\2/e,enum/
        # --regex-groovy=/^[ \t]*[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/~\3/m,package method/
        # --regex-groovy=/^[ \t]*public[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/+\3/m,public method/
        # --regex-groovy=/^[ \t]*protected[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/#\3/m,protected method/
        # --regex-groovy=/^[ \t]*private[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/-\3/m,private method/
        # --regex-groovy=/^[ \t]*[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][A-Za-z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/~\2/f,property/
        # --regex-groovy=/^[ \t]*public[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/+\2/f,public field/
        # --regex-groovy=/^[ \t]*protected[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/#\2/f,protected field/
        # --regex-groovy=/^[ \t]*private[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/-\2/f,private field/

    ctags \
        --langdef=groovy \
        --langmap=groovy:.groovy \
        --regex-groovy='/^[ \t]*[(static|private|public|protected) \t]*(def|[A-Za-z0-9_.]+)[ \t]+([A-Za-z0-9_]+)[ \t]*\(/\2/f,function,functions/' \
        --regex-groovy='/^[ \t]*private def[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/v,private,private variables/' \
        --regex-groovy='/^[ \t]*public def[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/u,public,public variables/' \
        --regex-groovy='/^[ \t]*[abstract ( \t)]*[(private|public) ( \t)]*class[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/c,class,classes/' \
        --regex-groovy='/^[ \t]*[abstract ( \t)]*[(private|public) ( \t)]*enum[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/c,class,classes/' \
        -R --fields=+zln
    cat tags | grep -F $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g')
        file=$(echo $line | awk '{print $2}')
        end=$(awk 'NR > first && /^}$/ { print NR; exit }' first=$ini $file)
        # end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
        #                          NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done
}

ctags_index_rust(){
    ctags \
        --langdef=Rust \
        --langmap=Rust:.rs \
        --regex-Rust='/fn +([a-zA-Z0-9_]+) *[(<{]/\1/f,functions,function definitions/' \
        --regex-Rust='/(type|enum|struct|trait)[ \t]+([a-zA-Z0-9_]+) *[<{(;]/\2/T,types,type definitions/' \
        --regex-Rust='/mod[ \t]+([a-zA-Z0-9_]+) *[<{(;]/\1/M,modules,module definitions/' \
        --regex-Rust='/(static|const) +([a-zA-Z0-9_]+) *[:=]/\2/c,consts,static constants/' \
        --regex-Rust='/macro_rules! +([a-zA-Z0-9_]+) *\{/\1/d,macros,macro definitions/' \
        --regex-Rust='/impl([ \t\n]*<[^>]*>)?[ \t]+(([a-zA-Z0-9_:]+)[ \t]*(<[^>]*>)?[ \t]+(for)[ \t]+)?([a-zA-Z0-9_]+)/\6/i,impls,trait implementations/' \
        -R --fields=+zln
    cat tags | grep $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g') 
        file=$(echo $line | awk '{print $2}') 
        end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
                                 NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done > tags2
    \mv tags2 tags
}

ctags_index_python () {
    rm -fr tags
    funcs=()

    while IFS= read -r line; do
      funcs+=("$line")
    done < <(ctags -x --python-kinds=f $(find . -name '*.py') 2>/dev/null | awk '$2=="function"{print $1, $3, $4}' | sort -k3,3 -k2n)

    current_file=""
    funcs_in_file=()

    process_file() {
      local file=$1
      local total_lines=$(cat "$file" | wc -l)
      local name=""
      local start=0
      local end=0

      for ((i=1; i <= ${#funcs_in_file[@]}; i++)); do
        name=$(echo "${funcs_in_file[$i]}" | awk '{print $1}')
        start=$(echo "${funcs_in_file[$i]}" | awk '{print $2}')

        if (( i < ${#funcs_in_file[@]} )); then
          end=$(echo "${funcs_in_file[$((i+1))]}" | awk '{print $2}')
          ((end--))
        else
          end=$total_lines
        fi

        echo "$name\t$(echo $file | sed 's/^..//g')\tkind:f\tline:$start\tend:$end" >> tags
      done
    }

    for line in "${funcs[@]}"; do
      name=$(echo "$line" | awk '{print $1}')
      start=$(echo "$line" | awk '{print $2}')
      archivo=$(echo "$line" | awk '{print $3}')
      if [[ "$archivo" != "$current_file" ]]; then
        if [[ -n "$current_file" ]]; then
          process_file "$current_file"
        fi
        current_file="$archivo"
        funcs_in_file=()
      fi
      funcs_in_file+=("$name $start $archivo")
    done

    if [[ -n "$current_file" ]]; then
      process_file "$current_file"
    fi
}

table_multirepos(){
    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        find -type f -not -path './.git/*' | while read line
        do
            filename=$(basename "$line")
            extension="${filename##*.}"
            echo $extension
        done | sort | uniq -c | sort -g | tac > extensions
        cd ..
    done

    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        cat extensions | head -n3 | awk '{print $2}' | while read line; do find -iname "*.$line" | Xargs cat ; done > serialized
        cat serialized | tokenize | sort | uniq -c | sort -g > words
        cd ..
    done

    rm -fr stopwords
    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        tail -n200 words | awk '{print $2}' | grep -v '^$' >> ../stopwords
        cd ..
    done
    cat stopwords | sort -u > stopwords_2; \mv stopwords_2 stopwords

    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        comm -23 <(cat words | awk '{print $2}' | grep -v '^$' | sort -u) <(cat ../stopwords | sort -u) > kwords
        cat kwords | grep -v -e '^[0-9a-f]*$' -e '^.\{1,5\}$' > kwords_2; \mv kwords_2 kwords
        cd ..
    done

    rm -fr kwords
    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        cat kwords >> ../kwords
        cd ..
    done

    cat kwords | sort | uniq -c | sort -g | awk '$1>1{print $2}' | grep -v -e '^[0-9]' | sort | while read kword
    do
    	echo -n "$kword : "
        find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
        do
    		[ $(grep $kword $line/kwords | wc -l) -gt 0 ] && echo -n "$line,"
    	done
    	echo
    done | tee kwords_repo

    rm -fr /tmp/cnt; mkdir /tmp/cnt
    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read repo1
    do
    	find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | grep -B1000 $repo1 | sed '1d' | while read repo2
    	do
    		[ $repo1 = $repo2 ] && continue
    		cnt=$(cat kwords_repo | grep ",$repo1," | grep ",$repo2," | wc -l)
    		[ -e /tmp/cnt/$repo1-$repo2 ] && cnt_prev=$(cat /tmp/cnt/$repo1-$repo2) || cnt_prev=0
    		echo $(( $cnt_prev + $cnt )) > /tmp/cnt/$repo1-$repo2
    	done
    done
    (cd /tmp/cnt; for a in *; do echo "$(cat $a) $a"; done | awk '$1>0{print $2}' | sort -g | tail -n50 | sed 's/-/ <--> /g' | sort -u)

    find -maxdepth 1 -type d | grep -v '^.$' | sed 's/^..//g' | while read line
    do
        cd $line
        echo "$line $(Git log_oneline_format | wc -l) $(Git log_oneline_format | awk '{print $2}' | sort | uniq -c | sort -g | tail -n1 | awk '{print $2}') $(Git log --pretty=format:"%x09%ad" | head -n1 | awk '{print $2"-"$5}') $(cat extensions | sed 's/^ *//g' | head -n3 | paste -d, -s | sed 's/ /:/g')"
        cd ..
    done | awk '{print $2,$0}' | sort -g | awk '{$1=""; print}' | column -t -s' '
}

ctags_extract(){
	cat tags | grep -F $1 | while read line
 	do
		fname="$(echo $line | awk '{print $1}')"
		file="$(echo $line | awk '{print $2}')"
	   	start="$(echo $line | sed 's/.*line:\([0-9]*\).*/\1/g')"
		end="$(echo $line | sed 's/.*end:\([0-9]*\).*/\1/g')"
		echo "cat $file | head -n $end | tail -n $(( $end - $start + 1 )) >> functions/$fname"
   	done
    if [ -e /tmp/ctags_extra_keywords ]
    then
        cat /tmp/ctags_extra_keywords | while read line
        do
            echo "touch functions/$line"
        done
    fi
}

ctags_extract(){
	cat tags | mgrep - $* | while read line
 	do
		fname="$(echo $line | awk '{print $1}')"
		file="$(echo $line | awk '{print $2}')"
	   	start="$(echo $line | sed 's/.*line:\([0-9]*\).*/\1/g')"
		end="$(echo $line | sed 's/.*end:\([0-9]*\).*/\1/g')"
		echo "cat $file | head -n $end | tail -n $(( $end - $start + 1 )) >> functions/$fname"
   	done
    if [ -e /tmp/ctags_extra_keywords ]
    then
        cat /tmp/ctags_extra_keywords | while read line
        do
            echo "touch functions/$line"
        done
    fi
}

ctags_extract_2() {
    cat tags | mgrep - $* | while read line
    do
        fname="$(echo $line | awk '{print $1}')"
        file="$(echo $line | awk '{print $2}')"
        start="$(echo $line | sed 's/.*line:\([0-9]*\).*/\1/g')"
        end="$(echo $line | sed 's/.*end:\([0-9]*\).*/\1/g')"
        echo "cat $file | head -n $end | tail -n $(( $end - $start + 1 )) | sed \"s|^|$file:$start |g\" >> functions/$fname"
    done
    if [ -e /tmp/ctags_extra_keywords ]
    then
        cat /tmp/ctags_extra_keywords | while read line
        do
            echo "touch functions/$line"
        done
    fi
}

ctags_info(){
    cd functions

	#grep -Rin 'log\.' G Msg | sed 's/^\([^:]*\):.*.Msg."\([^"]*\)".*/\2 -> \1/g' > /tmp/log2fn

	ls | sort -u > /tmp/list
	ls | while read fname
	do
        comm -12 <(sed 1d $fname | sed -e 's|//.*||g' -e 's|"[^"]*"||g' -e 's|os\.[a-zA-Z]*||g' | keywords_lowercase=false tokenize | sort -u) <(cat /tmp/list) | while read call
		do
			echo "$fname -> $call"
		done
	done | while read line
    do
        a="$(echo $line | sed 's| -> |@|g' | cut -d@ -f1)"
        b="$(echo $line | sed 's| -> |@|g' | cut -d@ -f2)"
        [ "$a" != "$b" ] && echo "$a -> $b"
    done > /tmp/calls

    cd ..

    cat tags | grep $1 | sed -e 's/\t/@/g' -e 's/line://g' -e 's/end://g' | awk 'BEGIN{FS="@"}{print $1" "$2" "$5" "$7}' > /tmp/index
}

ctags_adapt(){
    cat /tmp/calls $LOG2GR_DIR/$1/calls_add | grep -v '^#' | sed 's/ #.*//g' | sort -u > /tmp/calls_2
    comm -23 <(sort -u /tmp/calls_2) <(sort -u $LOG2GR_DIR/$1/calls_rm | grep -v '^#' | sed 's/ #.*//g') > /tmp/calls_3
    sort -u /tmp/calls_3 | sed 's/ #.*//g' > /tmp/calls

    cat /tmp/index | while read line
    do
        fn=$(echo $line | awk '{print $1}')
        if [ "$(cat $LOG2GR_DIR/$1/index_rm | grep -v '^#' | sed 's/ #.*//g' | grep "^$fn$")" = "" ]
        then
            echo $line
        fi
    done > /tmp/index_2
    cat $LOG2GR_DIR/$1/index_add | grep -v '^#' | sed 's/ #.*//g' >> /tmp/index_2
    sort -u /tmp/index_2 | sed 's/ #.*//g' > /tmp/index

    cat /tmp/index | awk '{print $1": { link: http://github.com/organization/project/blob/master/"$2"\\#L"$3" }" }'  > /tmp/links
}

ctags_update(){
    [ -e $LOG2GR_DIR/$1/fix_pre ] && source $LOG2GR_DIR/$1/fix_pre
    ctags_index kind:f
    [ -e $LOG2GR_DIR/$1/fix_ctags ] && source $LOG2GR_DIR/$1/fix_ctags
    vim tags
    rm -fr functions
    mkdir functions
    ctags_extract kind:f | vimexec
    [ -e $LOG2GR_DIR/$1/fix_functions ] && source $LOG2GR_DIR/$1/fix_functions
    ctags_info kind:f
    ctags_adapt $1
    [ -e $LOG2GR_DIR/$1/fix_results ] && source $LOG2GR_DIR/$1/fix_results
    rm -fr functions tags
    meld /tmp/index ~/log2gr/$1/index
    meld /tmp/calls ~/log2gr/$1/calls
}

ctags_update_quick(){
    [ -e $LOG2GR_DIR/$1/fix_pre ] && source $LOG2GR_DIR/$1/fix_pre
    ctags_index kind:f
    [ -e $LOG2GR_DIR/$1/fix_ctags ] && source $LOG2GR_DIR/$1/fix_ctags
    rm -fr functions
    mkdir functions
    ctags_extract kind:f | source /dev/stdin
    [ -e $LOG2GR_DIR/$1/fix_functions ] && source $LOG2GR_DIR/$1/fix_functions
    ctags_info kind:f
    ctags_adapt $1
    [ -e $LOG2GR_DIR/$1/fix_results ] && source $LOG2GR_DIR/$1/fix_results
    rm -fr functions tags
    \cp /tmp/index ~/log2gr/$1/index
    \cp /tmp/calls ~/log2gr/$1/calls
}

ctags_update_keep(){
    [ -e $LOG2GR_DIR/$1/fix_pre ] && source $LOG2GR_DIR/$1/fix_pre
    ctags_index kind:f
    [ -e $LOG2GR_DIR/$1/fix_ctags ] && source $LOG2GR_DIR/$1/fix_ctags
    rm -fr functions
    mkdir functions
    ctags_extract kind:f | source /dev/stdin
    [ -e $LOG2GR_DIR/$1/fix_functions ] && source $LOG2GR_DIR/$1/fix_functions
    ctags_info kind:f
    ctags_adapt $1
    [ -e $LOG2GR_DIR/$1/fix_results ] && source $LOG2GR_DIR/$1/fix_results
    \cp /tmp/index ~/log2gr/$1/index
    \cp /tmp/calls ~/log2gr/$1/calls
}

ctags_insert(){
    function=$1
    file=$(cat index | grep "^$function " | cut -d' ' -f2)
    start=$(cat index | grep "^$function " | cut -d' ' -f3)
    end=$(cat index | grep "^$function " | cut -d' ' -f4)
    offset=$(( $( cat functions/$function | wc -l ) - ( $end - $start ) - 1 ))

    cat $file | head -n$(( $start - 1 )) > /tmp/file
    cat functions/$function >> /tmp/file
    tail -n+$(( $end + 1 )) $file >> /tmp/file
    \mv /tmp/file $file

    cat index | awk -v file=$file -v offset=$offset -v start=$start '$2==file && $3 > start {print $1" "$2" "$3 + offset" "$4 + offset; next} $2==file && $3==start {print $1" "$2" "$3" "$4 + offset; next}{print}' > /tmp/file

    \mv /tmp/file index
}

ctags_insert_review(){
    ctags_insert $1
    meld .
    cp /tmp/index .
    git checkout .
}

ctags_intersection(){
cat ~/log2gr/$1/calls | while read line
do
    n1=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1 | sed 's/\.//g')
    n2=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2 | sed 's/\.//g')

    [ "$(cat $2 | grep -v '^#.*' | grep "^$n1\$")" != "" ] &&
    [ "$(cat $2 | grep -v '^#.*' | grep "^$n2\$")" != "" ] &&
    echo "$n1 -> $n2"
done
}

ctags_intersection_frontier(){
mgrep_cross $2 ~/log2gr/$1/calls > /tmp/ctags_intersection_frontier_mgrep_cross
cat $2 | while read line
do
    cat /tmp/ctags_intersection_frontier_mgrep_cross | while read call_line
    do
        n1=$(echo $call_line | sed 's/ -> /@/g' | cut -d@ -f1)
        n2=$(echo $call_line | sed 's/ -> /@/g' | cut -d@ -f2)
        [ $n2 = $line ] && echo "$n1 -> $n2"
    done
done
}

ctags_update_branch(){
    base=$(Git branch_base)
    leaf=$(Git branch_current)

    [ -e /tmp/ctags_extra_keywords ] && \mv /tmp/ctags_extra_keywords{,_bak}

    git checkout $base
    ctags_update_keep $1
    (cd functions; md5sum *) > /tmp/functions_base
    cat tags > /tmp/tags_base
    git clean -df

    git checkout $leaf
    ctags_update_keep $1
    (cd functions; md5sum *) > /tmp/functions_leaf
    cat tags > /tmp/tags_leaf
    git clean -df

    [ -e /tmp/ctags_extra_keywords_bak ] && \mv /tmp/ctags_extra_keywords{_bak,}
}

ctags_review(){
    rm -fr /tmp/ctags_extra_keywords

    source ~/.dotfiles/pkg/Ubuntu_22_04/goplantuml/umldiff
    umldiff
    umldiff_clean
    cat /tmp/uml_diffs > /tmp/ctags_extra_keywords

    ctags_update_branch $1
    comm -3 <(sort /tmp/functions_base) <(sort /tmp/functions_leaf) >> /tmp/ctags_extra_keywords

    sed -i \
        -e 's/\<bool\>//g' \
        -e 's/\<int\>//g' \
        -e 's/\<string\>//g' \
        -e 's/(.*//g' \
        -e 's/\./\n/g' \
        -e 's/[0-9a-f]\{32\}//g' \
        -e 's/^\t//g' \
        -e 's/^ *//g' \
        -e 's/ .*//g' \
        /tmp/ctags_extra_keywords

    cat /tmp/ctags_extra_keywords | sort -u | grep -v '^$' > /tmp/ctags_extra_keywords_2
    \mv /tmp/ctags_extra_keywords_2 /tmp/ctags_extra_keywords

    vim /tmp/ctags_extra_keywords

    ctags_update_quick $1
    ctags_intersection $1 /tmp/ctags_extra_keywords | sed 's/->/-->/g' | tee /tmp/review | Xclip -i

    comm -3 <(cat /tmp/functions_base | awk '{print $2}' | sort -u) <(cat /tmp/functions_leaf | awk '{print $2}' | sort -u) > /tmp/newfunctions
    ctags_update_keep $1
    mkdir functions/input
    cat /tmp/newfunctions | while read line; do mv functions/$line functions/input; done
    find functions -maxdepth 1 -type f -delete
}

call_path(){
    src=$(echo $1 | sed 's/\./DOT/g')
	dst=$(echo $2 | sed 's/\./DOT/g')
    #echo $src $dst > /tmp/dj.log
	[ "$src" = "$dst" ] && cpath="" && return
    if [ ! -e /tmp/lgr_cp_cache/$src@$dst ]
    then
        dijkstra -dp $src <(echo 'digraph G {'; cat $LOG2GR_DIR/$project/calls | sed 's/\./DOT/g' ; echo '}') | paste -d' ' -s  | sed 's/;/\n/g' | grep '\[' | grep -v digraph > /tmp/dists
	    dist=$( cat /tmp/dists | grep "\<$dst\>" | grep -v "prev=\<$dst\>" | grep dist | sed 's/^[^=]*=\([0-9]*\)\.[0-9]*.*/\1/g' )
	    if [ "$dist" = "" ]
        then
            echo "" > /tmp/lgr_cp_cache/$src@$dst
            cpath=""
            return
        fi

	    djpath=$dst; node=$dst
	    while true
	    do
	    	prev=$(cat /tmp/dists | grep "\<$node\>" | grep -v "prev=\<$node\>" | cut -d= -f3 | sed 's/.$//g')
	    	node=$prev
	    	djpath=$node@$djpath
	    	[ "$node" = "$src" ] && break
	    done
        if [ "$dist" -lt $call_path_max_dist ]
        then
            ret=$( echo $djpath | sed 's/@/ -> /g' | sed 's/DOT/./g' )
            echo $ret > /tmp/lgr_cp_cache/$src@$dst
            cpath=$ret
        else
            echo "" > /tmp/lgr_cp_cache/$src@$dst
            cpath=""
        fi
    else
        cpath=$(cat /tmp/lgr_cp_cache/$src@$dst)
    fi
}

log2gr(){
    if [ $2 = '-' ]
    then
        cat > /tmp/log2gr_stdin
        project=$1; shift
        log=$1; shift
        log2gr $project /tmp/log2gr_stdin $*
        return
    fi

    project=$1; shift

    if [ "$(echo $1 | grep 'cache/[0-9a-f]\{32\}' )" != "" ]
    then
        cat $LOG2GR_DIR/$1 > $LOG2GR_DIR/$project/graph
        [ -e $LOG2GR_DIR/$1.log ] && \cp $LOG2GR_DIR/$1.log $LOG2GR_DIR/$project/log
        if [ -e $LOG2GR_DIR/$project/postprocess ]
        then
            ( cd $LOG2GR_DIR/$project; source ./postprocess )
        else
	        cat $LOG2GR_DIR/$project/graph
        fi
        return
    fi

    \cp $1 $LOG2GR_DIR/$project/log

    if [ -e $LOG2GR_DIR/$project/config ]
    then
        source $LOG2GR_DIR/$project/config
    else
        call_path_max_dist=3
        seed_stop_seed=true
        short_seed_len=20
        shortseed_stop_seed=true
        shortseed_stop_error=true
    fi
    echo "0 / 1" > /tmp/lgr_progress

    source $LOG2GR_DIR/$project/log2fn
	cat $1 | log2fn > /tmp/fn_trace; shift
    touch $LOG2GR_DIR/$project/short_seeds

    rm -fr /tmp/lgr_cp_cache; mkdir -p /tmp/lgr_cp_cache
    seeds=()
    short_seeds=()
    seed_mode=long
    if [ $# -gt 0 ]
    then
        for a in $*
        do
            [ $a = "," ]          && seed_mode=short
            [ $seed_mode = long ]  && seeds+=$a
            [ $seed_mode = short ] && short_seeds+=$a
        done
    else
        comm -12 <(sort -u $LOG2GR_DIR/$project/seeds)       <(sort -u /tmp/fn_trace) | while read a; do seeds+=$a; done
        comm -12 <(sort -u $LOG2GR_DIR/$project/short_seeds) <(sort -u /tmp/fn_trace) | while read a; do short_seeds+=$a; done
    fi

    log2gr_md5=$( (cat /tmp/fn_trace; cat $LOG2GR_DIR/$project/calls; echo $project; echo $seeds; echo $short_seeds; echo $short_seed_len; echo $call_path_max_dist; echo $shortseed_stop_seed; echo $seed_stop_seed; echo $shortseed_stop_error) | md5sum | awk '{print $1}' )

    if [ -e $LOG2GR_DIR/cache/$log2gr_md5 ]
    then
        cat $LOG2GR_DIR/cache/$log2gr_md5 > $LOG2GR_DIR/$project/graph
    else
	    rm -fr /tmp/lost_context /tmp/lost_context_all /tmp/ok_context

        echo > /tmp/lgr_pr_file
        (
	    for seed in $seeds
	    do
	    	cat /tmp/fn_trace | uniq
        done
	    for seed in $short_seeds
	    do
	    	cat /tmp/fn_trace | uniq | grep "^$seed\$" -A $short_seed_len
        done
        ) | wc -l | read lgr_progress_target

	    for seed in $seeds
	    do
            [ "$(cat /tmp/fn_trace | grep "^$seed\$")" = "" ] && continue
	    	stack="@$seed"
	    	inseed=false
            lock=false; prev_lock=false
			echo "$seed" >> /tmp/ok_context
	    	cat /tmp/fn_trace | uniq | while read input
	    	do
                echo >> /tmp/lgr_pr_file; echo "$(cat /tmp/lgr_pr_file | wc -l) / $lgr_progress_target" > /tmp/lgr_progress
                inseed_p=$inseed
                [ $input = $seed ] && [ $inseed = false ] && inseed_p=true && lock=true
                [ $input = $seed ] && [ $inseed = true  ] && [ $seed_stop_seed = true ] && inseed_p=false
                inseed=$inseed_p
                [ $input = "EOF" ] && inseed=false
                [ $inseed = false ] && continue
	    		stack_bak=$stack
	    		error=false
                lock=true
	    		while true
	    		do
	    			last=$(echo $stack | sed 's/@/\n/g' | tail -n1 )
	    			stack=$(echo $stack | sed 's/@[^@]*$//g')
                    call_path $last $input
	    			[ "$cpath" != "" ] && [ $inseed = true ] && { break }
	    			[ "$stack" = "" ] && { stack=$stack_bak; error=true; lock=false; echo $input >> /tmp/lost_context_all; [ $prev_lock = true ] && echo $input >> /tmp/lost_context; break }
	    		done
                prev_lock=$lock
	    		[ $error = true ] && continue
                echo $input >> /tmp/ok_context
	    		stack="$stack@$(echo $cpath | sed 's/ -> /@/g')"
	    		echo $cpath
	    	done
	    done | while read line; do echo $line | sed 's/ -> /\n/g' | awk 'NR>1{print prev " -> " $0}{ prev=$0 }'; done | sort -u > $LOG2GR_DIR/$project/graph

	    for seed in $short_seeds
	    do
            [ "$(cat /tmp/fn_trace | grep "^$seed\$")" = "" ] && continue
	    	stack="@$seed"
	    	inseed=false
	    	cat /tmp/fn_trace | uniq | grep "^$seed\$" -A $short_seed_len | while read input
	    	do
                echo >> /tmp/lgr_pr_file; echo "$(cat /tmp/lgr_pr_file | wc -l) / $lgr_progress_target" > /tmp/lgr_progress
                inseed_p=$inseed
                [ $input = $seed ] && [ $inseed = false ] && inseed_p=true
                [ $input = $seed ] && [ $inseed = true  ] && [ $shortseed_stop_seed = true ] && inseed_p=false
                inseed=$inseed_p
                [ $inseed = false ] && continue
	    		stack_bak=$stack
	    		error=false
	    		while true
	    		do
	    			last=$(echo $stack | sed 's/@/\n/g' | tail -n1 )
	    			stack=$(echo $stack | sed 's/@[^@]*$//g')
                    call_path $last $input
	    			[ "$cpath" != "" ] && { error=false; break }
	    			[ "$stack" = "" ] && { stack=$stack_bak; error=true; break }
                    [ $error = true ] && [ $inseed = true ] && [ $shortseed_stop_error = true ] && inseed=false
                    [ $inseed = false ] && continue
                    [ $error = true ] && continue
	    		done
	    		[ $error = true ] && continue
                [ $inseed = false ] && continue
	    		stack="$stack@$(echo $cpath | sed 's/ -> /@/g')"
	    		echo $cpath
	    	done
	    done | while read line; do echo $line | sed 's/ -> /\n/g' | awk 'NR>1{print prev " -> " $0}{ prev=$0 }'; done | sort -u >> $LOG2GR_DIR/$project/graph

        cat $LOG2GR_DIR/$project/graph | sort -u > /tmp/graph; \mv /tmp/graph $LOG2GR_DIR/$project/graph

        cp $LOG2GR_DIR/$project/graph $LOG2GR_DIR/cache/$log2gr_md5
        cp $LOG2GR_DIR/$project/log $LOG2GR_DIR/cache/$log2gr_md5.log
    fi

    if [ -e $LOG2GR_DIR/$project/postprocess ]
    then
        ( cd $LOG2GR_DIR/$project; source ./postprocess )
    else
	    cat $LOG2GR_DIR/$project/graph
    fi

}

log2gr_seeds_1(){
    while true
    do
        log2gr $1 $2
        comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/seeds
        [ "$(cat /tmp/seeds)" = "" ] && break
        comm -23 <(sort /tmp/seeds) <(sort $LOG2GR_DIR/$1/seeds) | head -n1 >> $LOG2GR_DIR/$1/seeds
    done
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_2(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_3(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort $LOG2GR_DIR/$1/seeds) <(sort /tmp/call_seeds) > /tmp/seeds; \mv /tmp/seeds $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_4(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_5(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_6(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
}

log2gr_seeds(){
    touch $LOG2GR_DIR/cache/empty
    rm -fr $LOG2GR_DIR/cache/*
    echo main > $LOG2GR_DIR/$1/seeds
    rm -fr $LOG2GR_DIR/$1/short_seeds

    log2gr $1 $2
    cat /tmp/lost_context | sort -u > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/short_seeds
    comm -23 <(sort -u /tmp/short_seeds) <(sort -u $LOG2GR_DIR/$1/seeds) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
}

lgr_postprocess(){
cat << EOF
sed -i 's/\./@/g' graph
\cp graph{,.bak}
touch prev_graph

comm -12 <(sort -u graph) <(sort -u prev_graph) > /tmp/graph
comm -23 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: green } }/g' >> /tmp/graph
comm -13 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: red } }/g' >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat tooltips | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat style | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

\mv /tmp/graph graph
sed -i 's/@/\\\\./g' graph
EOF
}

lgr_postprocess(){
cat << EOF
sed -i 's/\./@/g' graph
\cp graph{,.bak}
touch prev_graph

if [ "\$(cat prev_graph)" = "" ]
then
    \cp graph prev_graph
    \cp log prev_log
fi

comm -12 <(sort -u graph) <(sort -u prev_graph) > /tmp/graph
comm -23 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: green } }/g' >> /tmp/graph
comm -13 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: red } }/g' >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat tooltips | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

comm -23 <( cat graph | sed 's/ -> /\n/g' | sort | uniq ) <( cat prev_graph | sed 's/ -> /\n/g' | sort | uniq ) | while read line
do
    echo "\$line: { style: { fill: '#EAFFEA'; stroke: green }  }"
done >> /tmp/graph

comm -13 <( cat graph | sed 's/ -> /\n/g' | sort | uniq ) <( cat prev_graph | sed 's/ -> /\n/g' | sort | uniq ) | while read line
do
    echo "\$line: { style: { fill: '#FFEAEA'; stroke: red }  }"
done >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat links | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

log2fnlog(){
    cat \$1 | while read line
    do
        file=\$(echo \$line | sed 's|.*"caller":"\\([^:]*\\):.*|\1|g')
        linenr=\$(echo \$line | sed 's|.*"caller":"[^:]*:\\([0-9]*\\).*|\1|g')
        function=\$(cat index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}')
        echo \$function \$line
    done | sed -e 's/"time":[0-9]*//g' > fnlog_\$1
}

log2fnlog log
log2fnlog prev_log

comm -12 <(cat graph.bak | sed 's/ -> /\n/g' | sort | uniq) <(cat prev_graph | sed 's/ -> /\n/' | sort | uniq ) | sed 's/@/./g' | while read node
do
    md51=\$(cat      fnlog_log | grep "^\$node " | sort | uniq | md5sum | awk '{print \$1}')
    md52=\$(cat fnlog_prev_log | grep "^\$node " | sort | uniq | md5sum | awk '{print \$1}')
    [ \$md51 != \$md52 ] && echo "\$node : {style: {fill: '#FFFFEA'; stroke: yellow}}" | sed 's/\./@/g'
done >> /tmp/graph

if [ "\$(cat prev_graph)" = "\$(cat graph.bak)" ]
then
    \rm prev_graph
    \rm prev_log
fi

\mv /tmp/graph graph
sed -i 's/@/\\\\./g' graph
EOF
}

lgr_log2fn(){
cat << EOF
log2fn(){
echo main
cat | sed 's/caller/\ncaller/g' | grep caller | cut -d'"' -f3 | while read line
do
    file=\$(echo \$line | cut -d: -f1)
    linenr=\$(echo \$line | cut -d: -f2)
    cat index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}'
done
}
EOF
}

lgr_log2fn(){
cat << EOF
log2fn(){
cat > /tmp/log2fn
log2fn_md5=\$(cat /tmp/log2fn ~/log2gr/project/index | md5sum | awk '{print \$1}')
if [ -e ~/log2gr/cache/\$log2fn_md5 ]
then
    cat ~/log2gr/cache/\$log2fn_md5
else
    echo main > /tmp/log2fn_out
    cat /tmp/log2fn | sed 's/caller/\ncaller/g' | grep caller | cut -d'"' -f3 | while read line
    do
        file=\$(echo \$line | cut -d: -f1)
        linenr=\$(echo \$line | cut -d: -f2)
        cat ~/log2gr/project/index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}'
    done >> /tmp/log2fn_out
    \cp /tmp/log2fn_out ~/log2gr/cache/\$log2fn_md5
    cat ~/log2gr/cache/\$log2fn_md5
fi
}
EOF
}

log2gr_compare(){
    log2gr $1 $2
    \cp $LOG2GR_DIR/$1/{graph.bak,prev_graph}
    \cp $LOG2GR_DIR/$1/{log,prev_log}
    log2gr $1 $3
}

log2gr_compare_logs(){
    fn=$1
    meld <(cat $LOG2GR_DIR/$project/fnlog_prev_log G "^$fn " | sort | uniq) <(cat $LOG2GR_DIR/$project/fnlog_log G "^$fn " | sort | uniq)
}

log2gr_steps(){
[ $1 = 'nok' ] && logfile=prev_log || logfile=log
grep -Rn "$(cat $LOG2GR_DIR/$project/short_seeds_filters | paste -d@ -s | sed -e 's/@/\\|/g' -e 's/^/\\(/g' -e 's/$/\\)/g')" $LOG2GR_DIR/$project/$logfile > /tmp/filter_log

while read -u3 line
do
    linenr=$(echo $line | sed 's/^\([^:]*\):.*/\1/g')
    linemsg=$(echo $line | sed 's/^\([^:]*:\)//g')

    head -n $linenr $LOG2GR_DIR/$project/$logfile > /tmp/step_log
    echo $linenr $linemsg
    read
done 3< /tmp/filter_log
cat $LOG2GR_DIR/$project/$logfile > /tmp/step_log
}

log2gr_disambiguate(){
    line=$1
    md5=$(echo $line | md5sum | awk '{print $1}')
    src=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    dst=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)
    srcline=$(cat /tmp/index | grep "^\<$src\>" | head -n1)
    srcfile=$(echo $srcline | awk '{print $2}')
    srcline=$(echo $srcline | awk '{print $3}')
    tmux send-keys -t .1 ":o $srcfile" Enter ":$srcline" Enter '/' "\<$dst\>" Enter gd
    sleep .1
    dstline=$(tmc .1 | grep '^ NOR')
    dstfile=$(echo $dstline | awk '{print $2}')
    dstline=$(echo $dstline | awk '{print $5}' | cut -d: -f1)
    echo "===== $line"
    echo "$srcfile $srcline -> $dstfile $dstline"
}

log2gr_disambiguate_2(){
    line=$1
    echo "===== $line"
    md5=$(echo $line | md5sum | awk '{print $1}')
    src=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    dst=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)
    srcline=$(cat /tmp/index | grep "^\<$src\>" | head -n1)
    srcfile=$(echo $srcline | awk '{print $2}')
    endline=$(echo $srcline | awk '{print $4}')
    srcline=$(echo $srcline | awk '{print $3}')
    psrcline=0
    tmux send-keys -t .1 ":o $srcfile" Enter ":$srcline" Enter 'j/' "\<$dst\>" Enter
    while true
    do
        sleep .1
        srcline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
        tmux send-keys -t .1 gd
        sleep .1
        dstline=$(tmc .1 | grep '^ NOR')
        dstfile=$(echo $dstline | awk '{print $2}')
        dstline=$(echo $dstline | awk '{print $5}' | cut -d: -f1)
        echo "$srcfile $srcline -> $dstfile $dstline"
        tmux send-keys -t .1 C-o; sleep .1; tmux send-keys -t .1 n
        sleep .1
        psrcline=$srcline
        srcline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
        [ $srcline -lt $psrcline -o $srcline -gt $endline ] && break
    done
}

log2gr_disambiguate_3() {
    line=$1
    echo "===== $line"
    md5=$(echo $line | md5sum | awk '{print $1}')
    src=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    dst=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)
    srcline=$(cat /tmp/index | grep "^\<$src\>" | head -n1)
    srcfile=$(echo $srcline | awk '{print $2}')
    endline=$(echo $srcline | awk '{print $4}')
    srcline=$(echo $srcline | awk '{print $3}')
    psrcline=0
    tmux send-keys -t .1 ":o $srcfile" Enter ":$srcline" Enter 'j/' "\<$dst\>" Enter
    sleep .1
    while true
    do
        sleep .1
        srcline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)

        retfile=$(tmc .1 | grep '^ NOR' | awk '{print $2}')
        retline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
        curfile=""
        curline=""

        tmux send-keys -t .1 gd
        sleep .1
        dstline=$(tmc .1 | grep '^ NOR')
        dstfile=$(echo $dstline | awk '{print $2}')
        dstline=$(echo $dstline | awk '{print $5}' | cut -d: -f1)
        echo "$srcfile $srcline -> $dstfile $dstline"

        while true
        do
            curfile=$(tmc .1 | grep '^ NOR' | awk '{print $2}')
            curline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
            [ "$curfile" = "$retfile" -a "$curline" = "$retline" ] && break
            tmux send-keys -t .1 C-o
            sleep .1
            curfile=$(tmc .1 | grep '^ NOR' | awk '{print $2}')
            curline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
            [ "$curfile" = "$retfile" -a "$curline" = "$retline" ] && break
        done

        tmux send-keys -t .1 n
        psrcline=$srcline
        srcline=$(tmc .1 | grep '^ NOR' | awk '{print $5}' | cut -d: -f1)
        [ $srcline -lt $psrcline -o $srcline -gt $endline ] && break
    done
}

log2gr_disambiguate_all() {
    line=$1
    src=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    dst=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)
    cat /tmp/all_functions | grep "^..$dst\$" | sed "s/^/$src -> /g"
}

idx_add_upd(){
    cat $LOG2GR_DIR/$1/index_add | grep -v '^#' | while read line
    do
    	fn=$(echo $line | cut -d' ' -f1 | sed 's/\.//g')
    	fl=$(echo $line | cut -d' ' -f2)
    	st=$(echo $line | cut -d' ' -f3)
    	ed=$(echo $line | cut -d' ' -f4)
    	echo $fn $fl
    done | sort -u > /tmp/index_add

    cat tags | sed -e 's/\t/@/g' -e 's/line://g' -e 's/end://g' | awk 'BEGIN{FS="@"}{print $1" "$2" "$5" "$7}' > /tmp/tagsindex

    mgrep_cross /tmp/index_add /tmp/tagsindex | while read line
    do
    	fn=$(echo $line | cut -d' ' -f1)
    	fl=$(echo $line | cut -d' ' -f2)
    	st=$(echo $line | cut -d' ' -f3)
    	ed=$(echo $line | cut -d' ' -f4)
    	echo $fn $fl $st $ed
    done | sort -u > /tmp/index_add_2
    meld /tmp/index_add_2 $LOG2GR_DIR/$1/index_add
}

idx_add_upd_quick(){
    cat $LOG2GR_DIR/$1/index_add | grep -v '^#' | while read line
    do
    	fn=$(echo $line | cut -d' ' -f1 | sed 's/\.//g')
    	fl=$(echo $line | cut -d' ' -f2)
    	st=$(echo $line | cut -d' ' -f3)
    	ed=$(echo $line | cut -d' ' -f4)
    	echo $fn $fl
    done | sort -u > /tmp/index_add

    cat tags | sed -e 's/\t/@/g' -e 's/line://g' -e 's/end://g' | awk 'BEGIN{FS="@"}{print $1" "$2" "$5" "$7}' > /tmp/tagsindex

    mgrep_cross /tmp/index_add /tmp/tagsindex | while read line
    do
    	fn=$(echo $line | cut -d' ' -f1)
    	fl=$(echo $line | cut -d' ' -f2)
    	st=$(echo $line | cut -d' ' -f3)
    	ed=$(echo $line | cut -d' ' -f4)
    	echo $fn $fl $st $ed
    done | sort -u > /tmp/index_add_2
    if [ $(cat /tmp/index_add_2 | wc -l) != $(cat $LOG2GR_DIR/$1/index_add | wc -l) ]
    then
        meld /tmp/index_add_2 $LOG2GR_DIR/$1/index_add
    else
        \cp /tmp/index_add_2 $LOG2GR_DIR/$1/index_add
    fi
}

cdag(){
    if [ $# = 1 ]
    then
        cat $1 | sed '1d' > /tmp/cdag_file
        cat $1 | head -n1 | sed 's/ /\n/g' > /tmp/cdag_vars
        cdag /tmp/cdag_vars /tmp/cdag_file
        return
    else
        vars=$1
        code=$2
        if [ $vars = auto ]
        then
            cat $code | grep = | while read line
            do
                l=$(echo $line | cut -d'=' -f1 | tokenize | grep -v '^$' | tail -n1)
                echo $l
            done | sort -u > /tmp/cdag_vars
            cdag /tmp/cdag_vars $code
            return
        else
            cat $code | grep = | while read line
            do
                l=$(echo $line | cut -d'=' -f1 | tokenize | grep -v '^$' | tail -n1)
                r=$(echo $line | cut -d'=' -f2 | tokenize | grep -v '^$')
                r2=$(comm -12 <(echo $r | sort -u) <(cat $vars | sort -u))

                #echo $line
                #echo "====="
                #echo $l
                #echo "====="
                #echo $r
                #echo "====="
                #echo $r2
                echo $r2 | while read a
                do
                    echo "$a --> $l"
                done

            done | while read line
            do
                l=$(echo $line | sed 's/ --> .*//g')
                r=$(echo $line | sed 's/.* --> //g')
                [ "$l" != "$r" ] && echo "$l --> $r"
            done | sort -u
        fi
    fi
}

ct_procdupli(){echo '-e '"'s|^"$1'\\t.*'$2'|'$(cat ~/log2gr/project/duplifiles | grep "^$2 " | cut -d" " -f2)$1'\\t'$2'|g'"'"' \\'}
ct_procdupli2(){echo '-e '"'s|\<"$(cat ~/log2gr/project/duplifiles | grep "^$2 " | cut -d" " -f2)$1'\>|'$(cat ~/log2gr/project/duplifiles | grep "^$2 " | cut -d" " -f2).$1'|g'"'"' \\'}
