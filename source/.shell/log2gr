[ -e ~/log2gr ] && LOG2GR_DIR=~/log2gr

ctags_index(){
    ctags -R --fields=+zln
    cat tags | grep -F $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g')
        file=$(echo $line | awk '{print $2}')
        end=$(awk 'NR > first && /^}$/ { print NR; exit }' first=$ini $file)
        # end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
        #                          NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done > tags2
    \mv tags2 tags
}

ctags_index_groovy(){
        #--regex-groovy='/^[ \t]*[(private|public|protected) ( \t)]*def[ \t]+([A-Za-z0-9_]+)[ \t()=]*\{/\1/f,function,functions/' \*/

        # --langdef=groovy
        # --langmap=groovy:.groovy
        # --regex-groovy=/^[ \t]*package[ \t]+([a-zA-Z0-9.-_]+)/\1/p,package/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*(abstract|final|static)?[ \t]*class[ \t]+([A-Za-z0-9_]+)/\3/c,class/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*interface[ \t]+([A-Za-z0-9_]+)/\2/i,interface/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*trait[ \t]+([A-Za-z0-9_]+)/\2/t,trait/
        # --regex-groovy=/^[ \t]*(private|public)?[ \t]*enum[ \t]+([A-Za-z0-9_]+)/\2/e,enum/
        # --regex-groovy=/^[ \t]*[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/~\3/m,package method/
        # --regex-groovy=/^[ \t]*public[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/+\3/m,public method/
        # --regex-groovy=/^[ \t]*protected[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/#\3/m,protected method/
        # --regex-groovy=/^[ \t]*private[ \t]+[(abstract|final|static) \t]*((def|void|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+)?([a-zA-Z0-9_]+\(.*\))[ \t]+/-\3/m,private method/
        # --regex-groovy=/^[ \t]*[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][A-Za-z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/~\2/f,property/
        # --regex-groovy=/^[ \t]*public[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/+\2/f,public field/
        # --regex-groovy=/^[ \t]*protected[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/#\2/f,protected field/
        # --regex-groovy=/^[ \t]*private[ \t]+[(final|static|synchronized) \t]*(def|byte|int|short|long|float|double|boolean|char|[A-Z][a-zA-Z0-9_]*)[ \t]+([a-zA-Z0-9_]+)([ \t]*[\/]+.*)?/-\2/f,private field/

    ctags \
        --langdef=groovy \
        --langmap=groovy:.groovy \
        --regex-groovy='/^[ \t]*[(static|private|public|protected) \t]*(def|[A-Za-z0-9_.]+)[ \t]+([A-Za-z0-9_]+)[ \t]*\(/\2/f,function,functions/' \
        --regex-groovy='/^[ \t]*private def[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/v,private,private variables/' \
        --regex-groovy='/^[ \t]*public def[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/u,public,public variables/' \
        --regex-groovy='/^[ \t]*[abstract ( \t)]*[(private|public) ( \t)]*class[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/c,class,classes/' \
        --regex-groovy='/^[ \t]*[abstract ( \t)]*[(private|public) ( \t)]*enum[ \t]+([A-Za-z0-9_]+)[ \t]*/\1/c,class,classes/' \
        -R --fields=+zln
    cat tags | grep -F $1 | while read line
    do
        ini=$(echo $line | sed 's/.*line:\([^ \t]*\)[ \t].*/\1/g')
        file=$(echo $line | awk '{print $2}')
        end=$(awk 'NR > first && /^}$/ { print NR; exit }' first=$ini $file)
        # end=$(awk -v first=$ini 'NR>=first && /{/              {c++}
        #                          NR>=first && /}/ && c && !--c {print NR; exit}' $file)
        echo "${line}\tend:${end}"
    done
}

ctags_extract(){
	cat tags | grep -F $1 | while read line
 	do
		fname="$(echo $line | awk '{print $1}')"
		file="$(echo $line | awk '{print $2}')"
	   	start="$(echo $line | sed 's/.*line:\([0-9]*\).*/\1/g')"
		end="$(echo $line | sed 's/.*end:\([0-9]*\).*/\1/g')"
		echo "cat $file | head -n $end | tail -n $(( $end - $start + 1 )) > functions/$fname"
   	done
}

ctags_info(){
    cd functions

	#grep -Rin 'log\.' G Msg | sed 's/^\([^:]*\):.*.Msg."\([^"]*\)".*/\2 -> \1/g' > /tmp/log2fn

	ls | sort -u > /tmp/list
	ls | while read fname
	do
        comm -12 <(sed 1d $fname | sed -e 's|//.*||g' -e 's|"[^"]*"||g' -e 's|os\.[a-zA-Z]*||g' | keywords_lowercase=false tokenize | sort -u) <(cat /tmp/list) | while read call
		do
			echo "$fname -> $call"
		done
	done | while read line
    do
        a="$(echo $line | sed 's| -> |@|g' | cut -d@ -f1)"
        b="$(echo $line | sed 's| -> |@|g' | cut -d@ -f2)"
        [ "$a" != "$b" ] && echo "$a -> $b"
    done > /tmp/calls

    cd ..

    cat tags | grep $1 | sed -e 's/\t/@/g' -e 's/line://g' -e 's/end://g' | awk 'BEGIN{FS="@"}{print $1" "$2" "$5" "$7}' > /tmp/index
}

ctags_adapt(){
    comm -23 <(sort -u /tmp/calls) <(sort -u $LOG2GR_DIR/$1/calls_rm | sed 's/ #.*//g') > /tmp/calls_2
    cat $LOG2GR_DIR/$1/calls_add | sed 's/ #.*//g' >> /tmp/calls_2
    sort -u /tmp/calls_2 | sed 's/ #.*//g' > /tmp/calls

    cat /tmp/index | while read line
    do
        fn=$(echo $line | awk '{print $1}')
        if [ "$(cat $LOG2GR_DIR/$1/index_rm | sed 's/ #.*//g' | grep "^$fn$")" = "" ]
        then
            echo $line
        fi
    done > /tmp/index_2
    cat $LOG2GR_DIR/$1/index_add | sed 's/ #.*//g' >> /tmp/index_2
    sort -u /tmp/index_2 | sed 's/ #.*//g' > /tmp/index

    cat /tmp/index | awk '{print $1": { link: http://github.com/organization/project/blob/master/"$2"\\#L"$3" }" }'  > /tmp/links
}

ctags_update(){
    ctags_index kind:f
    [ -e $LOG2GR_DIR/$1/fix_ctags ] && source $LOG2GR_DIR/$1/fix_ctags
    vim tags
    rm -fr functions
    mkdir functions
    ctags_extract kind:f | vimexec
    [ -e $LOG2GR_DIR/$1/fix_functions ] && source $LOG2GR_DIR/$1/fix_functions
    ctags_info kind:f
    ctags_adapt $1
    [ -e $LOG2GR_DIR/$1/fix_results ] && source $LOG2GR_DIR/$1/fix_results
    rm -fr functions tags
    meld /tmp/index ~/log2gr/$1/index
    meld /tmp/calls ~/log2gr/$1/calls
}

ctags_update_quick(){
    ctags_index kind:f
    [ -e $LOG2GR_DIR/$1/fix_ctags ] && source $LOG2GR_DIR/$1/fix_ctags
    rm -fr functions
    mkdir functions
    ctags_extract kind:f | source /dev/stdin
    [ -e $LOG2GR_DIR/$1/fix_functions ] && source $LOG2GR_DIR/$1/fix_functions
    ctags_info kind:f
    ctags_adapt $1
    [ -e $LOG2GR_DIR/$1/fix_results ] && source $LOG2GR_DIR/$1/fix_results
    rm -fr functions tags
    \cp /tmp/index ~/log2gr/$1/index
    \cp /tmp/calls ~/log2gr/$1/calls
}

ctags_insert(){
    function=$1
    file=$(cat index | grep "^$function " | cut -d' ' -f2)
    start=$(cat index | grep "^$function " | cut -d' ' -f3)
    end=$(cat index | grep "^$function " | cut -d' ' -f4)
    offset=$(( $( cat functions/$function | wc -l ) - ( $end - $start ) - 1 ))

    cat $file | head -n$(( $start - 1 )) > /tmp/file
    cat functions/$function >> /tmp/file
    tail -n+$(( $end + 1 )) $file >> /tmp/file
    \mv /tmp/file $file

    cat index | awk -v file=$file -v offset=$offset -v start=$start '$2==file && $3 > start {print $1" "$2" "$3 + offset" "$4 + offset; next} $2==file && $3==start {print $1" "$2" "$3" "$4 + offset; next}{print}' > /tmp/file

    \mv /tmp/file index
}

ctags_intersection(){
cat ~/log2gr/$1/calls | while read line
do
    n1=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    n2=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)

    [ "$(cat $2 | grep "^$n1\$")" != "" ] &&
    [ "$(cat $2 | grep "^$n2\$")" != "" ] &&
    echo "$n1 -> $n2"
done
}

call_path(){
    src=$(echo $1 | sed 's/\./DOT/g')
	dst=$(echo $2 | sed 's/\./DOT/g')
    #echo $src $dst > /tmp/dj.log
	[ "$src" = "$dst" ] && cpath="" && return
    if [ ! -e /tmp/lgr_cp_cache/$src@$dst ]
    then
        dijkstra -dp $src <(echo 'digraph G {'; cat $LOG2GR_DIR/$project/calls | sed 's/\./DOT/g' ; echo '}') | paste -d' ' -s  | sed 's/;/\n/g' | grep '\[' | grep -v digraph > /tmp/dists
	    dist=$( cat /tmp/dists | grep "\<$dst\>" | grep -v "prev=\<$dst\>" | grep dist | sed 's/^[^=]*=\([0-9]*\)\.[0-9]*.*/\1/g' )
	    if [ "$dist" = "" ]
        then
            echo "" > /tmp/lgr_cp_cache/$src@$dst
            cpath=""
            return
        fi

	    djpath=$dst; node=$dst
	    while true
	    do
	    	prev=$(cat /tmp/dists | grep "\<$node\>" | grep -v "prev=\<$node\>" | cut -d= -f3 | sed 's/.$//g')
	    	node=$prev
	    	djpath=$node@$djpath
	    	[ "$node" = "$src" ] && break
	    done
        if [ "$dist" -lt $call_path_max_dist ]
        then
            ret=$( echo $djpath | sed 's/@/ -> /g' | sed 's/DOT/./g' )
            echo $ret > /tmp/lgr_cp_cache/$src@$dst
            cpath=$ret
        else
            echo "" > /tmp/lgr_cp_cache/$src@$dst
            cpath=""
        fi
    else
        cpath=$(cat /tmp/lgr_cp_cache/$src@$dst)
    fi
}

log2gr(){
    if [ $2 = '-' ]
    then
        cat > /tmp/log2gr_stdin
        project=$1; shift
        log=$1; shift
        log2gr $project /tmp/log2gr_stdin $*
        return
    fi

    project=$1; shift

    if [ "$(echo $1 | grep 'cache/[0-9a-f]\{32\}' )" != "" ]
    then
        cat $LOG2GR_DIR/$1 > $LOG2GR_DIR/$project/graph
        [ -e $LOG2GR_DIR/$1.log ] && \cp $LOG2GR_DIR/$1.log $LOG2GR_DIR/$project/log
        if [ -e $LOG2GR_DIR/$project/postprocess ]
        then
            ( cd $LOG2GR_DIR/$project; source ./postprocess )
        else
	        cat $LOG2GR_DIR/$project/graph
        fi
        return
    fi

    \cp $1 $LOG2GR_DIR/$project/log

    if [ -e $LOG2GR_DIR/$project/config ]
    then
        source $LOG2GR_DIR/$project/config
    else
        call_path_max_dist=3
        seed_stop_seed=true
        short_seed_len=20
        shortseed_stop_seed=true
        shortseed_stop_error=true
    fi
    echo "0 / 1" > /tmp/lgr_progress

    source $LOG2GR_DIR/$project/log2fn
	cat $1 | log2fn > /tmp/fn_trace; shift
    touch $LOG2GR_DIR/$project/short_seeds

    mkdir -p /tmp/lgr_cp_cache/empty; rm -fr /tmp/lgr_cp_cache/*
    seeds=()
    short_seeds=()
    seed_mode=long
    if [ $# -gt 0 ]
    then
        for a in $*
        do
            [ $a = "," ]          && seed_mode=short
            [ $seed_mode = long ]  && seeds+=$a
            [ $seed_mode = short ] && short_seeds+=$a
        done
    else
        comm -12 <(sort -u $LOG2GR_DIR/$project/seeds)       <(sort -u /tmp/fn_trace) | while read a; do seeds+=$a; done
        comm -12 <(sort -u $LOG2GR_DIR/$project/short_seeds) <(sort -u /tmp/fn_trace) | while read a; do short_seeds+=$a; done
    fi

    log2gr_md5=$( (cat /tmp/fn_trace; cat $LOG2GR_DIR/$project/calls; echo $project; echo $seeds; echo $short_seeds; echo $short_seed_len; echo $call_path_max_dist; echo $shortseed_stop_seed; echo $seed_stop_seed; echo $shortseed_stop_error) | md5sum | awk '{print $1}' )

    if [ -e $LOG2GR_DIR/cache/$log2gr_md5 ]
    then
        cat $LOG2GR_DIR/cache/$log2gr_md5 > $LOG2GR_DIR/$project/graph
    else
	    rm -fr /tmp/lost_context /tmp/lost_context_all /tmp/ok_context

        echo > /tmp/lgr_pr_file
        (
	    for seed in $seeds
	    do
	    	cat /tmp/fn_trace | uniq
        done
	    for seed in $short_seeds
	    do
	    	cat /tmp/fn_trace | uniq | grep "^$seed\$" -A $short_seed_len
        done
        ) | wc -l | read lgr_progress_target

	    for seed in $seeds
	    do
            [ "$(cat /tmp/fn_trace | grep "^$seed\$")" = "" ] && continue
	    	stack="@$seed"
	    	inseed=false
            lock=false; prev_lock=false
			echo "$seed" >> /tmp/ok_context
	    	cat /tmp/fn_trace | uniq | while read input
	    	do
                echo >> /tmp/lgr_pr_file; echo "$(cat /tmp/lgr_pr_file | wc -l) / $lgr_progress_target" > /tmp/lgr_progress
                inseed_p=$inseed
                [ $input = $seed ] && [ $inseed = false ] && inseed_p=true && lock=true
                [ $input = $seed ] && [ $inseed = true  ] && [ $seed_stop_seed = true ] && inseed_p=false
                inseed=$inseed_p
                [ $input = "EOF" ] && inseed=false
                [ $inseed = false ] && continue
	    		stack_bak=$stack
	    		error=false
                lock=true
	    		while true
	    		do
	    			last=$(echo $stack | sed 's/@/\n/g' | tail -n1 )
	    			stack=$(echo $stack | sed 's/@[^@]*$//g')
                    call_path $last $input
	    			[ "$cpath" != "" ] && [ $inseed = true ] && { break }
	    			[ "$stack" = "" ] && { stack=$stack_bak; error=true; lock=false; echo $input >> /tmp/lost_context_all; [ $prev_lock = true ] && echo $input >> /tmp/lost_context; break }
	    		done
                prev_lock=$lock
	    		[ $error = true ] && continue
                echo $input >> /tmp/ok_context
	    		stack="$stack@$(echo $cpath | sed 's/ -> /@/g')"
	    		echo $cpath
	    	done
	    done | while read line; do echo $line | sed 's/ -> /\n/g' | awk 'NR>1{print prev " -> " $0}{ prev=$0 }'; done | sort -u > $LOG2GR_DIR/$project/graph

	    for seed in $short_seeds
	    do
            [ "$(cat /tmp/fn_trace | grep "^$seed\$")" = "" ] && continue
	    	stack="@$seed"
	    	inseed=false
	    	cat /tmp/fn_trace | uniq | grep "^$seed\$" -A $short_seed_len | while read input
	    	do
                echo >> /tmp/lgr_pr_file; echo "$(cat /tmp/lgr_pr_file | wc -l) / $lgr_progress_target" > /tmp/lgr_progress
                inseed_p=$inseed
                [ $input = $seed ] && [ $inseed = false ] && inseed_p=true
                [ $input = $seed ] && [ $inseed = true  ] && [ $shortseed_stop_seed = true ] && inseed_p=false
                inseed=$inseed_p
                [ $inseed = false ] && continue
	    		stack_bak=$stack
	    		error=false
	    		while true
	    		do
	    			last=$(echo $stack | sed 's/@/\n/g' | tail -n1 )
	    			stack=$(echo $stack | sed 's/@[^@]*$//g')
                    call_path $last $input
	    			[ "$cpath" != "" ] && { error=false; break }
	    			[ "$stack" = "" ] && { stack=$stack_bak; error=true; break }
                    [ $error = true ] && [ $inseed = true ] && [ $shortseed_stop_error = true ] && inseed=false
                    [ $inseed = false ] && continue
                    [ $error = true ] && continue
	    		done
	    		[ $error = true ] && continue
                [ $inseed = false ] && continue
	    		stack="$stack@$(echo $cpath | sed 's/ -> /@/g')"
	    		echo $cpath
	    	done
	    done | while read line; do echo $line | sed 's/ -> /\n/g' | awk 'NR>1{print prev " -> " $0}{ prev=$0 }'; done | sort -u >> $LOG2GR_DIR/$project/graph

        cat $LOG2GR_DIR/$project/graph | sort -u > /tmp/graph; \mv /tmp/graph $LOG2GR_DIR/$project/graph

        cp $LOG2GR_DIR/$project/graph $LOG2GR_DIR/cache/$log2gr_md5
        cp $LOG2GR_DIR/$project/log $LOG2GR_DIR/cache/$log2gr_md5.log
    fi

    if [ -e $LOG2GR_DIR/$project/postprocess ]
    then
        ( cd $LOG2GR_DIR/$project; source ./postprocess )
    else
	    cat $LOG2GR_DIR/$project/graph
    fi

}

log2gr_seeds_1(){
    while true
    do
        log2gr $1 $2
        comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/seeds
        [ "$(cat /tmp/seeds)" = "" ] && break
        comm -23 <(sort /tmp/seeds) <(sort $LOG2GR_DIR/$1/seeds) | head -n1 >> $LOG2GR_DIR/$1/seeds
    done
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_2(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_3(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort $LOG2GR_DIR/$1/seeds) <(sort /tmp/call_seeds) > /tmp/seeds; \mv /tmp/seeds $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_4(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_5(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) >> $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
}

log2gr_seeds_6(){
    echo main > $LOG2GR_DIR/$1/seeds
    log2gr $1 $2
    comm -23 <(sort -u /tmp/lost_context) <(sort -u /tmp/ok_context) > /tmp/lost
    comm -23 <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/calls | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/call_seeds
    comm -12 <(sort /tmp/lost) <(sort /tmp/call_seeds) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
}

log2gr_seeds(){
    touch $LOG2GR_DIR/cache/empty
    rm -fr $LOG2GR_DIR/cache/*
    echo main > $LOG2GR_DIR/$1/seeds
    rm -fr $LOG2GR_DIR/$1/short_seeds

    log2gr $1 $2
    cat /tmp/lost_context | sort -u > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
    comm -23 <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f1 | sort -u) <(cat $LOG2GR_DIR/$1/graph.bak | sed 's/ -> /@/g' | cut -d@ -f2 | sort -u) > /tmp/short_seeds
    comm -23 <(sort -u /tmp/short_seeds) <(sort -u $LOG2GR_DIR/$1/seeds) > $LOG2GR_DIR/$1/short_seeds
    log2gr $1 $2
}

lgr_postprocess(){
cat << EOF
sed -i 's/\./@/g' graph
\cp graph{,.bak}
touch prev_graph

comm -12 <(sort -u graph) <(sort -u prev_graph) > /tmp/graph
comm -23 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: green } }/g' >> /tmp/graph
comm -13 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: red } }/g' >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat tooltips | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat style | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

\mv /tmp/graph graph
sed -i 's/@/\\\\./g' graph
EOF
}

lgr_postprocess(){
cat << EOF
sed -i 's/\./@/g' graph
\cp graph{,.bak}
touch prev_graph

if [ "\$(cat prev_graph)" = "" ]
then
    \cp graph prev_graph
    \cp log prev_log
fi

comm -12 <(sort -u graph) <(sort -u prev_graph) > /tmp/graph
comm -23 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: green } }/g' >> /tmp/graph
comm -13 <(sort -u graph) <(sort -u prev_graph) | sed 's/$/: {style: { stroke: red } }/g' >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat tooltips | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

comm -23 <( cat graph | sed 's/ -> /\n/g' | sort | uniq ) <( cat prev_graph | sed 's/ -> /\n/g' | sort | uniq ) | while read line
do
    echo "\$line: { style: { fill: '#EAFFEA'; stroke: green }  }"
done >> /tmp/graph

comm -13 <( cat graph | sed 's/ -> /\n/g' | sort | uniq ) <( cat prev_graph | sed 's/ -> /\n/g' | sort | uniq ) | while read line
do
    echo "\$line: { style: { fill: '#FFEAEA'; stroke: red }  }"
done >> /tmp/graph

cat graph prev_graph | sed 's/ -> /\n/g' | sort | uniq | while read line
do
    cat links | sed 's/\./@/g' | grep "^\$line:"
done >> /tmp/graph

log2fnlog(){
    cat \$1 | while read line
    do
        file=\$(echo \$line | sed 's|.*"caller":"\\([^:]*\\):.*|\1|g')
        linenr=\$(echo \$line | sed 's|.*"caller":"[^:]*:\\([0-9]*\\).*|\1|g')
        function=\$(cat index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}')
        echo \$function \$line
    done | sed -e 's/"time":[0-9]*//g' > fnlog_\$1
}

log2fnlog log
log2fnlog prev_log

comm -12 <(cat graph.bak | sed 's/ -> /\n/g' | sort | uniq) <(cat prev_graph | sed 's/ -> /\n/' | sort | uniq ) | sed 's/@/./g' | while read node
do
    md51=\$(cat      fnlog_log | grep "^\$node " | sort | uniq | md5sum | awk '{print \$1}')
    md52=\$(cat fnlog_prev_log | grep "^\$node " | sort | uniq | md5sum | awk '{print \$1}')
    [ \$md51 != \$md52 ] && echo "\$node : {style: {fill: '#FFFFEA'; stroke: yellow}}" | sed 's/\./@/g'
done >> /tmp/graph

if [ "\$(cat prev_graph)" = "\$(cat graph.bak)" ]
then
    \rm prev_graph
    \rm prev_log
fi

\mv /tmp/graph graph
sed -i 's/@/\\\\./g' graph
EOF
}

lgr_log2fn(){
cat << EOF
log2fn(){
echo main
cat | sed 's/caller/\ncaller/g' | grep caller | cut -d'"' -f3 | while read line
do
    file=\$(echo \$line | cut -d: -f1)
    linenr=\$(echo \$line | cut -d: -f2)
    cat index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}'
done
}
EOF
}

lgr_log2fn(){
cat << EOF
log2fn(){
cat > /tmp/log2fn
log2fn_md5=\$(cat /tmp/log2fn ~/log2gr/project/index | md5sum | awk '{print \$1}')
if [ -e ~/log2gr/cache/\$log2fn_md5 ]
then
    cat ~/log2gr/cache/\$log2fn_md5
else
    echo main > /tmp/log2fn_out
    cat /tmp/log2fn | sed 's/caller/\ncaller/g' | grep caller | cut -d'"' -f3 | while read line
    do
        file=\$(echo \$line | cut -d: -f1)
        linenr=\$(echo \$line | cut -d: -f2)
        cat ~/log2gr/project/index | grep \$file | awk -v line=\$linenr '\$3<line && \$4>line{print \$1}'
    done >> /tmp/log2fn_out
    \cp /tmp/log2fn_out ~/log2gr/cache/\$log2fn_md5
    cat ~/log2gr/cache/\$log2fn_md5
fi
}
EOF
}

log2gr_compare(){
    log2gr $1 $2
    \cp $LOG2GR_DIR/$1/{graph.bak,prev_graph}
    \cp $LOG2GR_DIR/$1/{log,prev_log}
    log2gr $1 $3
}

log2gr_compare_logs(){
    fn=$1
    meld <(cat $LOG2GR_DIR/$project/fnlog_prev_log G "^$fn " | sort | uniq) <(cat $LOG2GR_DIR/$project/fnlog_log G "^$fn " | sort | uniq)
}

log2gr_disambiguate(){
    line=$1
    md5=$(echo $line | md5sum | awk '{print $1}')
    src=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f1)
    dst=$(echo $line | sed 's/ -> /@/g' | cut -d@ -f2)
    srcline=$(cat /tmp/index | grep "^\<$src\>" | head -n1)
    srcfile=$(echo $srcline | awk '{print $2}')
    srcline=$(echo $srcline | awk '{print $3}')
    tmux send-keys -t .1 ":o $srcfile" Enter ":$srcline" Enter '/' "\<$dst\>" Enter g d
    sleep .1
    dstline=$(tmc .1 | grep '^ NOR')
    dstfile=$(echo $dstline | awk '{print $2}')
    dstline=$(echo $dstline | awk '{print $5}' | cut -d: -f1)
    echo "$line"
    echo "$srcfile $srcline"
    echo "$dstfile $dstline"
}

