Git(){
    command=$1
    shift
    case $command in

        (log_graph) \git log --oneline --graph | grep '*  ' -B1000 -A3 ;;
        (log_follow) \git log --follow $* ;;
        (log_branch) \git log --oneline --graph | while read line; do [[ "$line" =~ '*  ' ]]  && break; echo "$line"; done ;;
        (log_oneline_format) \git log --pretty=format:"%h%x09%an%x09%ad%x09%s" ;;

        (diff_grep) \git diff --name-only -G"$1" ;;
        (diff_with_filename) \git diff $* | awk '/^\+\+\+/{print; $1=""; name=$0}{print name": "$0}' ;;
        (diff_name_only) \git diff --name-only $* ;;
        (diff_step) \git diff ${1}^ ${1} ;;
        (diff_staged) \git diff --staged ;;

        (branch_rewrite) \git rebase -i $(\git merge-base master $(\git rev-parse HEAD)) ;; # pick, squash, squash, squash...
        (branch_to_patch) \git diff $(\git merge-base master $(\git rev-parse HEAD)) $(\git rev-parse HEAD) ;;
        (branch_to_file) \git log --cc $(\git merge-base master $(\git rev-parse HEAD))...HEAD ;;
        (branch_to_file_2) \git format-patch --stdout $(\git merge-base master $(\git rev-parse HEAD)) ;; # consume with git am
        (branch_create) \git checkout -b $1 ;;
        (branch_push) \git push --set-upstream origin $(\git rev-parse --abbrev-ref HEAD) ;;
        (branch_rebase) \git checkout $1; \git rebase -i $2 ;;
        (branch_get_file) \git show $1:$2 > $2 ;;
        (branch_base) \git log --oneline --graph | head -n1000 | grep '*  ' | head -n1 | awk '{print $2}' ;;

        (reset_branch) \git reset --hard origin/$(\git rev-parse --abbrev-ref HEAD) ;;
        (reset_last_commit) \git reset HEAD^ ;;

        (pull_rebase) \git pull --rebase ;;
        (push_force_lease) \git push --force-with-lease ;;
        (clone_recursive) \git clone --recurse-submodules $* ;;
        (clean) \git clean -df ;;
        (list_excluded) \git ls-files -i -c --exclude-from=.gitignore ;;
        (interactive_checkout) \git checkout -p . ;;
        (interactive_add) \git add -p $* ;;
        (stash_save_all) \git add .; \git stash push -m "$1"; \git stash apply ;;
        (stash_save_staged) \git add -u; \git stash push -m "$1"; \git stash apply ;;
        (unstage) \git restore --staged $* ;;
        (status_uno) \git status -uno ;;
        (status_short) \git status -s ;;
        (cherrypick_no_commit) \git cherry-pick --no-commit $* ;;
        (undo_last_commit) \git reset --soft HEAD^;;
        (revert_multiple) \git revert --no-commit HEAD~3.. ;;
        (get_submodules) \git submodule update --init --recursive ;;

        (*) \git $command $*;;
    esac
}

git_filter_history(){
git filter-branch --env-filter '
WRONG_EMAIL="wrong@example.com"
NEW_NAME="New Name Value"
NEW_EMAIL="correct@example.com"

if [ "$GIT_COMMITTER_EMAIL" = "$WRONG_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$NEW_NAME"
    export GIT_COMMITTER_EMAIL="$NEW_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$WRONG_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$NEW_NAME"
    export GIT_AUTHOR_EMAIL="$NEW_EMAIL"
fi
' --tag-name-filter cat -- --branches --tags
}