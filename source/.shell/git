Git(){
    return
    command=$1
    shift
    case $command in

        (log_graph) \git log --oneline --graph | head ;;
        (log_follow) \git log --follow $* ;;

        (branch_rewrite) \git rebase -i $(\git merge-base master $(\git rev-parse HEAD)) ;; # pick, squash, squash, squash...
        (branch_to_patch) \git diff $(\git merge-base master $(\git rev-parse HEAD)) $(\git rev-parse HEAD) > ../patch.patch ;;
        (branch_to_file) \git log --cc $(\git merge-base master $(\git rev-parse HEAD))...HEAD > ../branch.patch ;;
        (branch_to_file_2) \git format-patch --stdout $(\git merge-base master $(\git rev-parse HEAD)) > ../branch2.patch ;;
        (branch_create) \git branch $1; git checkout $1 ;;
        (branch_push) \git push --set-upstream origin $(\git rev-parse --abbrev-ref HEAD) ;;
        (branch_rebase) \git checkout $1; \git rebase -i $2 ;;

        (pull_rebase) \git pull --rebase ;;

        (clean) \git clean -df ;;
        (list_excluded) \git ls-files -i -c --exclude-from=.gitignore ;;
        (interactive_checkout) \git checkout -p . ;;
        (stash_save_all) \git add .; \git stash push -m "$1"; \git stash apply ;;
        (stash_save_staged) \git add -u; \git stash push -m "$1"; \git stash apply ;;
        (remove_last_commit) \git reset --hard HEAD^ ;;
        (unstage) \git reset $* ;;
        (status_uno) \git status -uno ;;

        (*) \git $command $*;;
    esac
}
